package dport

import grails.transaction.Transactional
import org.apache.juli.logging.LogFactory
import org.broadinstitute.mpg.diabetes.metadata.PhenotypeBean
import org.broadinstitute.mpg.diabetes.metadata.Property
import org.broadinstitute.mpg.diabetes.metadata.PropertyBean
import org.broadinstitute.mpg.diabetes.metadata.SampleGroupBean

@Transactional
class MetadataUtilityService {

    private static final log = LogFactory.getLog(this)

    /***
     *   Take a list of Properties (as generated by getAllPropertiesWithNameForExperimentOfVersion and turn them into a, separated list of
     *   sample groups referencing individual phenotypes. This is the format that we need to pass to the REST API in order to ask for
     *   all of the phenotype values of a particular property.
     * @param propertyList
     * @return
     */
    public String createPhenotypePropertyFieldRequester(List<Property>  propertyList) {
        String returnValue = ""
        if (propertyList){
            // we will mostly iterate over this parent list
            List<PhenotypeBean> phenotypeBeanList = propertyList.collect{PropertyBean pb->return pb.parent}
            // create a list of sample groups associated with our property
            List <String> sampleGroupNames =  phenotypeBeanList.collect{PhenotypeBean pheno->return pheno.parent}.systemId?.sort()?.unique()
            List<String> eachSampleGroupsString = []
            for (String sampleGroupName in sampleGroupNames){
                List <String> phenotypeNames = phenotypeBeanList.findAll{PhenotypeBean phenotype->return phenotype.parent.systemId==sampleGroupName}.name
                eachSampleGroupsString << "\"$sampleGroupName\": [${phenotypeNames.collect {return "\"$it\""}.join(",")}]"
            }
            returnValue = eachSampleGroupsString.join(",")
        }
        return returnValue
    }




    public LinkedHashMap<String,List> createPhenotypeSampleNameMapper(List<Property>  propertyList) {
        LinkedHashMap<String,List> returnValue = [:]
        if (propertyList){
            // we will mostly iterate over this parent list
            List<PhenotypeBean> phenotypeBeanList = propertyList.collect{PropertyBean pb->return pb.parent}
            // create a list of sample groups associated with our property
            List <String> sampleNames =  phenotypeBeanList.collect{PhenotypeBean pheno->return pheno.parent}.name?.sort()?.unique()
            for (String sampleName in sampleNames){
                List <String> phenotypeNames = phenotypeBeanList.findAll{org.broadinstitute.mpg.diabetes.metadata.PhenotypeBean phenotype->return phenotype.parent.name==sampleName}.name
                returnValue[sampleName] = phenotypeNames
            }
        }
        return returnValue
    }




    /***
     *   Take a list of Properties (as generated by getAllPropertiesWithNameForExperimentOfVersion and turn them into a, separated list of
     *   sample groups. This is the format that we need to pass to the REST API in order to ask for properties at the label of a
     *   data set
     *
     * @param propertyList
     * @return
     */
    public String createSampleGroupPropertyFieldRequester(List<Property>  propertyList) {
        String returnValue = ""
        if (propertyList){

            // create a list of sample groups associated with our property
            List <String> sampleGroupNames =  createSampleGroupPropertyList(propertyList)

            returnValue = sampleGroupNames.collect {return "\"$it\""}.join(",")
        }
        return returnValue
    }


    public List <String> createSampleGroupPropertyList(List<Property>  propertyList) {
        List <String> returnValue = []
        if (propertyList){
            // we will mostly iterate over this parent list
            List<PropertyBean> propertyBeanList = propertyList.collect{PropertyBean pb->return pb.parent}
            // create a list of sample groups associated with our property
            List <String> sampleGroupNames =  propertyBeanList?.systemId?.sort()?.unique()

            returnValue = sampleGroupNames
        }
        return returnValue
    }


    public LinkedHashMap<String,String> createPhenotypeSampleGroupNameMap(List<Property>  propertyList) {
        LinkedHashMap<String,String>  returnValue = [:]
        if (propertyList){
            // we will mostly iterate over this parent list
            List<PhenotypeBean> phenotypeBeanList = propertyList.collect{PropertyBean pb->return pb.parent}
            // create a list of sample groups associated with our property
            for (PhenotypeBean phenotypeBean in phenotypeBeanList){
                if (!returnValue.containsKey(phenotypeBean.name)){
                    returnValue [phenotypeBean.name]  = phenotypeBean?.parent?.systemId
                } else {
                    log.error("NOTE: Phenotype = ${phenotypeBean.name} Unexpectedly found in multiple sample groups: createPhenotypeSampleGroupMap")
                }
            }
        }
        return returnValue
    }


    public LinkedHashMap<String,String> createPhenotypeSampleGroupMap(List<Property>  propertyList) {
        LinkedHashMap<String,String>  returnValue = [:]
        if (propertyList){
            // we will mostly iterate over this parent list
            List<PhenotypeBean> phenotypeBeanList = propertyList.collect{PropertyBean pb->return pb.parent}
            // create a list of sample groups associated with our property
            for (PhenotypeBean phenotypeBean in phenotypeBeanList){
                if (!returnValue.containsKey(phenotypeBean.name)){
                    returnValue [phenotypeBean.name]  = phenotypeBean?.parent?.systemId
                } else {
                    log.error("NOTE: Phenotype = ${phenotypeBean.name} Unexpectedly found in multiple sample groups: createPhenotypeSampleGroupMap")
                }
            }
        }
        return returnValue
    }

}
